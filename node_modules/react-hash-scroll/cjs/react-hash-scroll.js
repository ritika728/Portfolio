'use strict';

var React = require('react');
var reactRouterDom = require('react-router-dom');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/**
 * The default scroll function used by all components of this library
 */
var DEFAULT_SCROLL_FUNC = function (ref, behavior, position) {
    var _a;
    (_a = ref.current) === null || _a === void 0 ? void 0 : _a.scrollIntoView({
        behavior: behavior,
        block: position,
        inline: position,
    });
};

/**
 * The default scroll behavior used by all components of this library
 */
var DEFAULT_SCROLL_BEHAVIOR = "smooth";
/**
 * The default scroll position used by all components of this library
 */
var DEFAULT_SCROLL_POSITION = "center";

// React Imports
function useHashScroll(hash, options) {
    if (options === void 0) { options = {}; }
    var _a = reactRouterDom.useLocation(), urlHash = _a.hash, pathname = _a.pathname;
    var ref = React.useRef(null);
    var _b = options.behavior, behavior = _b === void 0 ? DEFAULT_SCROLL_BEHAVIOR : _b, _c = options.position, position = _c === void 0 ? DEFAULT_SCROLL_POSITION : _c, _d = options.scrollFunc, scrollFunc = _d === void 0 ? DEFAULT_SCROLL_FUNC : _d;
    var requiredPathname = options.requiredPathname;
    if (hash.charAt(0) !== "#") {
        hash = "#" + hash;
    }
    if (typeof requiredPathname === "string") {
        requiredPathname = [requiredPathname];
    }
    React.useEffect(function () {
        if (urlHash === hash &&
            (requiredPathname === undefined || requiredPathname.includes(pathname))) {
            if (ref.current) {
                scrollFunc(ref, behavior, position);
            }
        }
    }, [
        urlHash,
        ref,
        hash,
        requiredPathname,
        pathname,
        scrollFunc,
        behavior,
        position,
    ]);
    return ref;
}

//React Imports
/**
 * Scrolls to child element when the specified hash is present in the url
 *
 * Note: **ONLY** 1 child element allowed
 */
var HashScroll = function (_a) {
    var hash = _a.hash, children = _a.children, behavior = _a.behavior, position = _a.position, requiredPathname = _a.requiredPathname, scrollFunc = _a.scrollFunc;
    var childRef = useHashScroll(hash, {
        behavior: behavior,
        position: position,
        requiredPathname: requiredPathname,
        scrollFunc: scrollFunc,
    });
    return React.cloneElement(children, {
        ref: childRef,
    });
};

// React Imports
var createHashFunc = function (ref, options, defaultOptions, pathname) {
    var _a, _b, _c, _d, _e, _f, _g;
    var behavior = defaultOptions.behavior, position = defaultOptions.position, requiredPathname = defaultOptions.requiredPathname, scrollFunc = defaultOptions.scrollFunc;
    var req = (_a = options.requiredPathname) !== null && _a !== void 0 ? _a : requiredPathname;
    if (typeof req === "string")
        req = [req];
    var b = (_c = (_b = options.behavior) !== null && _b !== void 0 ? _b : behavior) !== null && _c !== void 0 ? _c : DEFAULT_SCROLL_BEHAVIOR;
    var p = (_e = (_d = options.position) !== null && _d !== void 0 ? _d : position) !== null && _e !== void 0 ? _e : DEFAULT_SCROLL_POSITION;
    var s = (_g = (_f = options.scrollFunc) !== null && _f !== void 0 ? _f : scrollFunc) !== null && _g !== void 0 ? _g : DEFAULT_SCROLL_FUNC;
    return function () {
        if ((req === undefined || req.includes(pathname)) && ref.current) {
            s(ref, b, p);
        }
    };
};
/**
 * Component that pairs hashes with refs and scrolls to a corresponding ref when one of the hashes is present in the url
 */
var MultiHash = function (_a) {
    var hashes = _a.hashes, children = _a.children, behavior = _a.behavior, position = _a.position, requiredPathname = _a.requiredPathname, scrollFunc = _a.scrollFunc;
    var _b = reactRouterDom.useLocation(), urlHash = _b.hash, pathname = _b.pathname;
    var defaultOptions = React.useMemo(function () { return ({ behavior: behavior, position: position, requiredPathname: requiredPathname, scrollFunc: scrollFunc }); }, [behavior, position, requiredPathname, scrollFunc]);
    var hashFuncs = React.useMemo(function () { return ({}); }, [
        hashes,
        defaultOptions,
        pathname,
    ]);
    React.useMemo(function () {
        for (var hash in hashes) {
            var value = hashes[hash];
            if (hash.charAt(0) !== "#") {
                hash = "#" + hash;
            }
            if (Array.isArray(value))
                hashFuncs[hash] = createHashFunc(value[0], value[1], defaultOptions, pathname);
            else
                hashFuncs[hash] = createHashFunc(value, {}, defaultOptions, pathname);
        }
    }, [hashes, defaultOptions, pathname]);
    React.useEffect(function () {
        var scroll = hashFuncs[urlHash];
        if (typeof scroll === "function") {
            scroll();
        }
    }, [urlHash, hashFuncs]);
    return React__default['default'].createElement(React__default['default'].Fragment, null, children);
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function warning(condition, message) {
  {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

var CHILDREN_HASH_UNEQUAL_LENGTHS = "The number of hashes and children should be the same so that each child corresponds to a hash (ChildrenHash) - React Hash Scroll";

var createChild = function (child, defaultOptions, hash) {
    if (!hash)
        return child;
    if (typeof hash === "string")
        return (React__default['default'].createElement(HashScroll, __assign({}, defaultOptions, { hash: hash }), child));
    return (React__default['default'].createElement(HashScroll, __assign({}, defaultOptions, hash), child));
};
/**
 * Scrolls to corresponding child element when one of the hashes is present in the url
 */
var ChildrenHash = function (_a) {
    var hashes = _a.hashes, children = _a.children, behavior = _a.behavior, position = _a.position, requiredPathname = _a.requiredPathname, scrollFunc = _a.scrollFunc;
    warning(hashes.length === children.length, CHILDREN_HASH_UNEQUAL_LENGTHS);
    return (React__default['default'].createElement(React__default['default'].Fragment, null, children.map(function (child, i) { return (React__default['default'].createElement(React.Fragment, { key: i }, createChild(child, {
        behavior: behavior,
        position: position,
        requiredPathname: requiredPathname,
        scrollFunc: scrollFunc,
    }, hashes[i]))); })));
};

exports.ChildrenHash = ChildrenHash;
exports.DEFAULT_SCROLL_BEHAVIOR = DEFAULT_SCROLL_BEHAVIOR;
exports.DEFAULT_SCROLL_FUNC = DEFAULT_SCROLL_FUNC;
exports.DEFAULT_SCROLL_POSITION = DEFAULT_SCROLL_POSITION;
exports.HashScroll = HashScroll;
exports.MultiHash = MultiHash;
exports.useHashScroll = useHashScroll;
//# sourceMappingURL=react-hash-scroll.js.map
